# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:light
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.4'
#       jupytext_version: 1.2.4
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# # Именователь полей в таблице

# Книжка помогает решить стандартную проблему - есть файл с колонками, которые названы по-русски. В базе данных мы хотим их видеть по-английски.
#
# Делать это каждый раз творчески надоело, попытка реализовать канонический путь.
#
# Как работает (идеологически) - идем от конца к началу (то есть выполняться будет в обратном порядке):
#
# * английские слова в имени конкатенируются через "_", если слово содержит "*", оно ставится в конец
# * каждое слово имени поля переводится на английский (или транслитерируется)
# * из имени поля выкидываются одиночные символы
# * из имени поля выкидываются исключения ("лишние слова")
# * слова в имени поля приводятся к нормальной форме (в смысле pymorphe2, из приведения исключаются слова "аббревиатуры")
# * слова в имени поля переводится в нижний регистр
# * спец. символы заменяются или удаляются в имени поля
#
# Для перевода используем словарь tranDict: он содержит соответствие нормальной формы русского слова английскому. Если в словаре нет слова, то оно будет транслитерировано. В словарь можно добавлять вручную.
#
# Пока непонятно (нет статистики) - как решать обратную задачу (есть поле в базе - как это поле называлось в оригинале), решим, когда будет более понятна потребность.

# здесь список колонок для инкрементов по регистрации типа _РЕГИСТРАЦИЯ_01_2019_ИНН.xlsx
rusHdr = """Федеральный округ,Экономический район,Регион,Марка,Модель+модификация,Модель,Модификация,
Год выпуска,Год регистрации,Квартал регистрации,Месяц регистрации,День регистрации,Количество,
Новые/подержанные,Vin код,Номер двигателя,Номер кузова,Номер шасси,Тип регистрации,Тип владения,
Округ (для Москвы),Район в области,Район в городе,Город,Населенный пункт,ОКАТО,OKTMO,
Региональный центр/область,Индекс (почтовый),Тип двигателя,Тип топлива,Объем двигателя,
Объем двигателя в диапазоне,Мощность двигателя (л/с),Тип руля,Тип кузова,Точная масса,
Снаряженная масса,Масса в сегменте 1,Масса в сегменте 2,Страна происхождения марки,
Часть света,Отечественные/зарубежные,Мировой производитель,Ценовой сегмент,
Страна производства (Vin код),Отечественные/зарубежные (Vin код),Производитель (Vin код),
ИНН,Название компании (налоговая инспекция),Первый код ОКВЭД (налоговая инспекция),
Расшифровка кода ОКВЭД (налоговая инспекция),ID,Класс для автомобиля"""

# это был список колонок для регистрации на 01.01.2019
rusHdr = """Тип ТС,Федеральный Округ,Регион,Областной район,Город,Прочие населенные пункты,
ОКАТО,OKTMO,ОКАТО региона,ОКТМО региона,Региональный центр/область,Марка,Модель + Модификация,Модель,Год выпуска,
Дата регистрации,Год регистрации,Месяц регистрации,Количество,VIN код,Номер двигателя,Номер кузова,Номер шасси,
Тип регистрации,Тип владения,Точная масса,Снаряженная масса,Масса в сегменте 1,Масса в сегменте 2,
Тип двигателя,Объем двигателя в диапазоне,Мощность двигателя (л/с),Тип топлива,Тип руля,Тип кузова,
Ценовой сегмент,Класс для автомобиля,Страна происхождения марки,Отечественные/зарубежные,
Производитель (по VIN коду),Страна производства (по VIN коду),Отечественные/зарубежные (по Vin коду),
ИНН компании,Название компании,Первый код ОКВЭД,Расшифровка кода ОКВЭД,Группа ОКВЭД,
Холдинг,ИНН Холдинга,Субхолдинг,ИНН Субхолдинга,Причина связи,Комментрий к причине связи,
Признак лизингового автомобиля,Лизинг статус по регистрации,ИНН лизингодателя,Лизингодатель наименование,
Холдинг лизингодателя,ИНН Холдинга лизингодателя,Лизингополучатель наименование,Адрес лизингополучателя,
ИНН лизингополучателя,Телефон лизингополучателя,E mail лизингополучателя,Первый код ОКВЭД лизингополучателя,
Расшифровка кода ОКВЭД лизингополучателя,Руководитель лизингополучателя,Должность лизингополучателя,ID"""

import pymorphy2
morph = pymorphy2.MorphAnalyzer()

# настройки
SEPR = ","

# слова аббревиатуры: они исключаются из приведения в нормальную форму
abbrList = [
    "окато", "октмо", "vin", "инн", "оквэд", "id", "mail", "email"
]

# лишние слова: эти слова просто выкидываются из имени полей
exclList = [
    "для", "по"
]

# получение нормальной формы слова (для вставки в словарь, например)
morph.parse("актуальность")[0].normal_form

# перевод слов - сюда можно и нужно добавлять, но нужно добавлять НОРМАЛЬНУЮ форму слова 
# см. ячейку выше - в ней можно получить нормальную форму слова
# звездочка в конце английского варианта означает, что слово будет поставлено в конец фразы
# если таких слов (со звездочками) много - получится как-то (как работает алгоритм ниже)
tranDict = {
    "тип": "type*",
    "инн": "inn*", # можно было бы транслитить, но тогда оно будет вначале, а не в конце
    "тс": "ts",
    "федеральный": "federal",
    "регион": "region",
    "район": "district",
    "город": "city",
    "прочий": "other",
    "населить": "inhabited", # населенный
    "пункт": "location", # потому что это от населенный пункт
    "региональный": "regional",
    "центр": "center",
    "область": "area",
    "марка": "made",
    "модель": "model",
    "модификация": "modification",
    "год": "year*",
    "выпуск": "made",
    "дата": "date*",
    "регистрация": "registrtation",
    "месяц": "month*",
    "количество": "quantity",
    "код": "code",
    "номер": "number*",
    "двигатель": "engine",
    "кузов": "body",
    "шасси": "chassis",
    "владение": "ownership",
    "точный": "exact",
    "масса": "weight*",
    "снарядить": "running_state", # снаряженная
    "сегмент": "segment",
    "объесть": "volume", # объем
    "диапазон": "range",
    "мощность": "power*",
    "топливо": "fuel",
    "руль": "wheel",
    "ценовый": "price",
    "класс": "class*",
    "автомобиль": "vehicle",
    "страна": "country",
    "происхождение": "origin",
    "отечественный": "russian",
    "зарубежный": "foreign",
    "производитель": "maker",
    "производство": "production",
    "компания": "company",
    "название": "name*",
    "наименование": "name*",
    "один": "first", # первый
    "расшифровка": "description*",
    "группа": "group*",
    "холдинг": "holding",
    "субхолдинг": "subholding",
    "причина": "reason",
    "связь": "link",
    "комментарий": "comment",
    "признак": "flag*",
    "лизинговый": "leased",
    "лизинг": "leasing",
    "статус": "status*",
    "лизингодатель": "leasing_company",
    "лизингополучатель": "leasee",
    "адрес": "address",
    "телефон": "phone",
    "руководитель": "director*",
    "должность": "role*",
    "новое": "new",
    "новый": "new",
    "владелец": "owner",
    "лицензия": "license",
    "разрешение": "permit",
    "начало": "start*",
    "окончание": "end*",
    "срок": "period",
    "действие": "validity",
    "прекращение": "termination",
    "актуальность": "actuality",
    "грз": "plate",
    "подержать": "used"
}


def creEngHdr ( rusHdr, debug=False ):
    """
    подготовка слов для перевода
    на вход подается строка русского заголовка rusHdr
    в результате получаем строку английского заголовка (в том же порядке)
    """
    fields = [ f.strip().lower() for f in rusHdr.split(SEPR)]
    engFields = []
    for fld in fields:
        fldList = []
        endList = []
        for wrd in fld.replace("(","").replace(")","").replace("+"," ").replace("/"," ").split():
        
            # исключим односимвольные слова
            if len(wrd)==1: continue
        
            # приводим к нормальной форме (кроме аббревиатур)
            normWrd = wrd if wrd in abbrList else morph.parse(wrd)[0].normal_form
        
            # исключаем лишние слова
            if normWrd in exclList:
                continue
        
            # переводим или транслитерируем
            if normWrd in tranDict.keys():
                engWord = tranDict[normWrd]
            else:
                engWord = transliterate(normWrd)
            
            # убираем слова со звездочкой в конец
            if engWord.find("*")>=0:
                endList.append(engWord.replace("*",""))
            else:
                fldList.append(engWord)
            
        fldList.extend(endList)
        newField = "_".join(fldList)
        while newField in engFields:
            newField += "1"
        if debug: print(fld, ":", newField)    
        engFields.append(newField)
    if len(engFields)!=len(fields):
        print("ЧТО-ТО ПОШЛО НЕ ТАК - ДЛИНЫ ЗАГОЛОВКОВ ПОЛУЧИЛИСЬ РАЗНЫЕ... {} -> {} английских".format(len(fields),len(engFields)))
    engHdr = SEPR.join(engFields)    
    return engHdr


# name: это строка которую транслитим
def transliterate(name):
   """
   Автор: LarsKort
   Дата: 16/07/2011; 1:05 GMT-4;
   Не претендую на "хорошесть" словарика. В моем случае и такой пойдет,
   вы всегда сможете добавить свои символы и даже слова. Только
   это нужно делать в обоих списках, иначе будет ошибка.
   """
   # Слоаврь с заменами
   slovar = {'а':'a','б':'b','в':'v','г':'g','д':'d','е':'e','ё':'e',
      'ж':'zh','з':'z','и':'i','й':'i','к':'k','л':'l','м':'m','н':'n',
      'о':'o','п':'p','р':'r','с':'s','т':'t','у':'u','ф':'f','х':'h',
      'ц':'c','ч':'cz','ш':'sh','щ':'scz','ъ':'','ы':'y','ь':'','э':'e',
      'ю':'u','я':'ja', 'А':'a','Б':'b','В':'v','Г':'g','Д':'d','Е':'e','Ё':'e',
      'Ж':'zh','З':'z','И':'i','Й':'i','К':'k','Л':'l','М':'m','Н':'n',
      'О':'o','П':'p','Р':'r','С':'s','Т':'t','У':'u','Ф':'Х','х':'h',
      'Ц':'c','Ч':'cz','Ш':'sh','Щ':'scz','Ъ':'','Ы':'y','Ь':'','Э':'e',
      'Ю':'u','Я':'ja',',':'','?':'',' ':'_','~':'','!':'','@':'','#':'',
      '$':'','%':'','^':'','&':'','*':'','(':'',')':'','-':'','=':'','+':'',
      ':':'',';':'','<':'','>':'','\'':'','"':'','\\':'','/':'','№':'',
      '[':'',']':'','{':'','}':'','ґ':'','ї':'', 'є':'','Ґ':'g','Ї':'i',
      'Є':'e'}
        
   # Циклически заменяем все буквы в строке
   for key in slovar:
      name = name.replace(key, slovar[key])
   return name
